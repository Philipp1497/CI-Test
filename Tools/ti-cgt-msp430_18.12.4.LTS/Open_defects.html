
<!-- saved from url=(0099)http://gtjenkins.itg.ti.com:8080/job/JIRA-SDOWP-Generate-Report/546/artifact/jira-query-report.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>
    table {border-collapse:collapse; table-layout:fixed; width:310px;}
    table td {border: none solid black; width:100px; word-wrap:break-word;}
    th {  background: #eee; }
    </style>
    </head>
    <body>
    <table style="text-align:left; width: 100%; border:1px solid #CCC;border:none;">
    <tbody><tr>
    
    <td align="left">
    <a href="http://www.ti.com/">
    <img alt="" src="data:image/gif;base64,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">
    </a>
    </td>
    </tr>
    <tr><td align="center"><h1>Open Defects in Release</h1></td></tr>
    </tbody></table>
    <table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
    <thead>
    <tr>
    <th align="center">ID</th>
    <th align="center">Summary</th>
    <th align="center">State</th>
    <th align="center">Reported In Release</th>
    <th align="center">Target Release</th>
    <th align="center">Workaround</th>
    <th align="center">Release Notes</th>
    </tr>
    </thead><tbody><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-6070?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-6070</a></td>
        <td>Erroneous "redeclared with incompatible type" involving two tagless structs with same form</td>
        <td>Planned</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>For this specific case, which involved the BLE stack:

Edit file blestack/inc/att.h

Find the typedef for attReadByTypeReq_t.  Give the struct a tag (name).  Any name will do as long as it is unique.  Do the same for attReadByGrpTypeReq_t.

Recompile all C files.

-or-

make sure all files are compiled as C or all files are compiled as C++.</td>
        <td>User-defined types defined in separate translation units are technically different types in C, but the C compiler merges them when it can determine that they are the same type, such as when there is a declaration in each translation unit for a symbol with external linkage.  This bug was caused by type merging being a bit too aggressive in merging two structs that had exactly the same form, with identical members, but distinct struct tags.  Type merging mistakenly thought it could merge these because it saw a function prototype that involved not exactly the same type, but a compatible type without a tag, and this function was later defined using both fully-defined types, this time with the struct tags.  This particular bug cannot happen as long as you always use a tag (name) when declaring a struct or union.  This is the name that appears after the keyword "struct" or "union" but before the opening curly brace.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4329?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4329</a></td>
        <td>Initializing unordered_map with an initializer_list fails with -o2 or higher</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code prints out 'wg size 1', instead of 'wg size 3', which is the expected value:



#include &lt;unordered_map&gt;

#include &lt;initializer_list&gt;



int main(void) {

	const std::pair&lt;const long, wchar_t&gt;

            wp0(0, L'i'), wp1(1, L'm'), wp2(2, L'p');



        std::initializer_list&lt;std::unordered_map&lt;long, wchar_t&gt;::value_type&gt;

            winit { wp0, wp1, wp2 };



	std::unordered_map&lt;long, wchar_t&gt; wg(winit);

        printf("wg size %zu\n", wg.size());

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4323?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4323</a></td>
        <td>1 ULP rounding error in double addition</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code prints '-0x1.d6f3457f35ba8p+26' for the value of high.

Using the gcc or TI arm compiler, the value is '-0x1.d6f3457f35ba7p+26'.



It appears to be a floating point rounding error caused by the addition (+) or subtraction (-) arithmetic operators.



#include &lt;cmath&gt;

#include &lt;stdio.h&gt;



#define         BOUND 0.00000001



double			 _x9 = -123456789.987654321;

double			 _y9 = 9.0;

double			 ans9 = -123456789.987654321;

int main()

{

    double val = std::nextafter(_x9, _y9);

    double low = ans9 - BOUND;

    double high = ans9 + BOUND;

    printf("%a %a (%zu)\n", _x9, _y9, sizeof(double));

    printf("%a &lt; %a &lt; %a ?\n", low, val, high);

    if (val &gt;= low &amp;&amp; val &lt;= high) printf("Yes!\n");

    else                           printf("No!\n");

}

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4318?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4318</a></td>
        <td>libcxx/include/random uses unsigned for unsigned long</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>LIBCXX/libcxx/include/random shown below uses unsigned instead of unsigned long for the "32" bit case of __lce_ta:



// 32

template &lt;unsigned long long _Ap, unsigned long long _Cp, unsigned long long _Mp&gt;

struct __lce_ta&lt;_Ap, _Cp, _Mp, (unsigned long)(~0), true&gt;

{

    typedef unsigned long result_type;

...



armcl/clang both compile with no errors.



msp430, however, has 16bit "unsigned" and fails with below error due to above issue where "unsigned" is used for 32 bit. It should use unsigned long instead:



"random", line 1890: error: incomplete type is not allowed

          detected during:

            instantiation of "std::__2::linear_congruential_engine&lt;_UIntType, __a, __c, __m&gt;::result_type std::__2::linear_congruential_engine&lt;_UIntType, __a, __c, __m&gt;::operator()() [with _UIntType=uint_fast32_t, __a=40014UL, __c=0UL, __m=2147483563UL]" at line 2651

            instantiation of "void std::__2::subtract_with_carry_engine&lt;_UIntType, __w, __s, __r&gt;::seed(std::__2::subtract_with_carry_engine&lt;_UIntType, __w, __s, __r&gt;::result_type, std::__2::integral_constant&lt;unsigned int, 1U&gt;) [with _UIntType=uint_fast32_t, __w=24UL, __s=10UL, __r=24UL]" at line 2576



Tests compile and pass if above __lce_ta is changed for 32bit case from unsigned to unsigned long.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4305?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4305</a></td>
        <td>Compiler aborts with excessive inlining of C++ functions</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4304?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4304</a></td>
        <td>runtime failure on unaligned access (on some processor variants, not all)</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code results in an unaligned access failure in the ARM simulator when compiled with:



armcl -mv5e -me --float_support=vfpv2



#include &lt;map&gt;

#include &lt;stdio.h&gt;



int main(void)

{

        std::map&lt;int, char&gt;::size_type n=9;

        std::map&lt;int, char&gt; g;

        char s[] = "contrived";

        for (int i=0; i&lt;n; i++) {

            char k = s[i];

            std::pair&lt;const int, char&gt; p((int)k, k);

            g.insert(p);

        }



        int i00 = 0;

        std::map&lt;int, char&gt;::iterator it00 = g.begin();

        printf("start for loop\n");

        while (it00++ != g.end())

        {

           printf("iteration %d\n", i00++);

        }

        printf("out of for loop\n");

        return (1);

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4297?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4297</a></td>
        <td>Cannot take the address of std::ctype&lt;char&gt;::table_size</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>This is a defect in the library. The table_size field is declared as having a constant value in the class definition, but there is no one definition for the field in the library.



Taking the address of this field will result in a link-time error.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4281?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4281</a></td>
        <td>Unexpected type returned by bitset [] operator</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The operator[] definition for std::bitset returns a const reference to an internally defined class type, rather than a bool as required by C++14 section 20.6.2</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4276?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4276</a></td>
        <td>std::multimap::clear is not noexcept</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The library does not declare std::multimap::clear as noexcept, which is required by C++14 section 23.4.5.1 paragraph 2</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4275?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4275</a></td>
        <td>std::num_get does not parse floating-point strings correctly</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>



The C++ library locale helper, std::num_get, currently fails to correctly parser floating-point values in strings and streams. These calculations will always result in the default value of 0.0 for doubles, and 0.0f for floats.



Please use the C library equivalents, such as sprintf, to perform such operations.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4259?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4259</a></td>
        <td>noexcept(typeid(d)) runtime fail on polymorphic class type</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4258?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4258</a></td>
        <td>deeply nested lambda functions hang the codegen</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4248?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4248</a></td>
        <td>armcl allows non-default arguments to be specified after default arguments</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code should emit a syntax error due to the specification of a second, non-defaulted argument after a defaulted argument. However, the compiler will abort with an internal error.



extern void foo(int, int);

void f() {

    auto l = [](int i=1, int j) { foo(i, j); };

    l();

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4247?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4247</a></td>
        <td>Internal error when assigning default arguments to a parameter pack</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C++14 standard explicitly prohibits assigning default arguments to a

template parameter pack. However, the compile accepts such code silently, and may result in an internal error during compilation.



template &lt;class... Types&gt; void f(Types... args) {

    auto lm = [](Types... = args...) {};

    lm(10); // internal error here

}

int main() { f(1, 23); return 0; }</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4245?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4245</a></td>
        <td>Multiple non-variables may be declared using auto or decltype(auto)</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>C++14 Section 7.1.6.4 paragraph 8 states that if multiple declarators are on the same line as an auto or decltype(auto) specifying, they must all be variable declarations.



However, our implementation does not enforce this requirement, allowing constructs of the following form:



auto f(void)-&gt;int, g(void)-&gt;char;</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4234?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4234</a></td>
        <td>No error generated for lambda-expression in default argument cannot capture any entity.</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4158?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4158</a></td>
        <td>TI compiler does not emit clang error: constexpr function never produces a constant expression</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4157?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4157</a></td>
        <td>error with using constexpr for return from end() with empty std::initializer_list</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4132?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4132</a></td>
        <td>cannot find matching "==" operator definition</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The library does not provide an definition of std::operator== for arguments of type std::istream_iterator. That is, the following code is erroneously marked as ill-formed with a diagnostic:



#include &lt;iterator&gt;

#include &lt;string&gt;

using ISTREAM_ITER_C = std::istream_iterator&lt;char, char&gt;;



bool foo(const ISTREAM_ITER_C&amp; arg00 ,const ISTREAM_ITER_C&amp; arg01 ){

	return std::operator==  (arg00, arg01); // Syntax error

}



However, this is only an issue if called in exactly that way. Using it as an operator, rather than as a function call, works as expected:



arg00 == arg01 // Works</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4124?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4124</a></td>
        <td>Failure to defer access control checks</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4122?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4122</a></td>
        <td>decltype cannot be used as a destructor name</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4119?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4119</a></td>
        <td>user-supplied allocator function is not called</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4099?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4099</a></td>
        <td>Composing operations for valarray may fail to compile</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Due to a potential implementation issue in the libc++ library, utilizing the valarray class and composing a result via multiple operations may fail.



For example:



const std::valarray&lt;float&gt; cl(6);

std::slice arg1(0,0,0);

std::slice slice(0,0,0);

cl[arg1][slice]; // Compilation error!</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4090?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4090</a></td>
        <td>Unimplemented core issue 475: std::uncaught_exception is not true when constructing the thrown object</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the code below, std::uncaught_exception should be true when constructing the A object that is constructed to be propagated to the catch block. The current implementation returns false.



#include &lt;exception&gt;

#include &lt;assert.h&gt;



struct A {

    int i;

    A() : i(0) {}

    A(const A&amp;) : i(std::uncaught_exception() ? 5 : 0) {}

    ~A() { }

};



int main()

{

    try {

        A a;

        assert(a.i == 0);

        throw a;

    } catch (A a) {

        assert(a.i == 5); // Fails

    }

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4087?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4087</a></td>
        <td>wostringstream::fill(WCHAR_MAX) incorrectly sets the fill value to ' 'L.</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4076?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4076</a></td>
        <td>Exception propagating out of noexcept function does not call std::terminate</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4072?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4072</a></td>
        <td>Unimplemented core issue 1769: Catching a thrown derived class by reference to base clas</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Core 1769, involving a resolution which states that derived classes can be thrown and caught by catch clauses denoting an unambiguous base, has not been implemented.



#include &lt;assert.h&gt;



struct BaseClass {

    int i;

    BaseClass() : i(0) { }

    BaseClass(int ii) : i(ii) { }

    BaseClass(const BaseClass&amp; r) : i(r.i) { }

};



class DerivedClass : BaseClass {

    int ib;

  public:

    DerivedClass(const DerivedClass&amp; r) : BaseClass(r.ib), ib(r.ib) { }

    DerivedClass(const BaseClass&amp;) : BaseClass(999), ib(999)  { }

    DerivedClass(int ii);

};



DerivedClass thrown_base (1);

DerivedClass::DerivedClass(int ii) : BaseClass(ii), ib(ii) { }



int main() {

    try {

        throw thrown_base;

        return 999;

    }

    catch(const BaseClass &amp;k) {                       }

    catch(...)                              { assert(false); } // Assertion fails at runtime due to core issue 1769

    return 0;

}

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4071?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4071</a></td>
        <td>&lt;regex&gt; never throws error_ctype</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Due to an implementation detail, the &lt;regex&gt; header will never throw an exception corresponding to std::regex_constants::error_ctype. This can be exhibited from the below code sample:



#include &lt;regex&gt;

int main(void) {



  try {

    std::regex e("[[:not_a_class:]]", std::regex_constants::ECMAScript);

    std::regex_match("a", e);

  }

  catch(std::regex_error e){

    // e.code() will not be std::regex_constants::error_ctype

  }

  return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4069?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4069</a></td>
        <td>std::linear_congruential_engine doesn't support 8-bit results</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Instantiations of std::linear_congruential_engine are only support for types between 64 and 16 bits. Therefore, on ARM and MSP430, the 'unsigned char' type is not supported.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4044?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4044</a></td>
        <td>libcxx istreambuf_iterator points to end of string instead of character past match</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The C++11 standard says that the "iterator is always left pointing one position beyond the last character successfully matched." In this case, that's after zero characters, so the iterator should point to the first character, just as the test expects. However, libcxx doesn't do this; it returns the pointer to the end of the string, which is indeed composed of characters that might match a (hex) float, but that's not the final word.



The libc++ code has advanced the iterator to "end," which it should not have done because the input sequence did not match. The test case expects the match to fail, leaving an iterator pointing to something other than "end," and it dereferences the iterator; because the iterator is actually "end", we get a NULL pointer dereference and hilarity ensues.



I claim this is a flaw in the the libc++ implementation.



cutdown test case:



#include &lt;locale&gt;

#include &lt;sstream&gt;

typedef std::char_traits&lt;char&gt; test1;

typedef std::istreambuf_iterator&lt;char, test1&gt; istr_it;

struct  mynum : public std::num_get&lt;char, istr_it&gt; 

{

   iter_type my_do_get(iter_type first, iter_type last, std::ios_base&amp; str, 

                       std::ios_base::iostate&amp; st, bool&amp; val) const

   { return (do_get(first, last, str, st, val)); }

};



int main()

{

   mynum my_num_get;

   std::ios_base::iostate st = std::ios_base::goodbit;

   std::istringstream istr("abcdef");

   istr_it first(istr.rdbuf()), last;



   st = std::ios_base::goodbit;

   double dv = 0;

   if(*(first = my_num_get.get(first, last, istr, st, dv)) == 'a')

      return 1;

}



</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4035?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4035</a></td>
        <td>Compiler allows constant subtraction between pointers to different objects</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The compiler allows the following code without error:



struct STR {

   constexpr STR(): arr1{1,2}, arr2{3,4} {};

   const char arr1[2];

   const char arr2[2];

};

const struct STR str;

constexpr char const *ptr1 =  str.arr1;

constexpr char const *ptr3 =  str.arr2;   



constexpr int diff2 = ptr3 - ptr1;



The definition of diff2 subtracts pointers to different objects, and should be disallowed.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4026?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4026</a></td>
        <td>Non-standard partial ordering of variadic template partial specialization</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4002?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4002</a></td>
        <td>Undefined behavior on lambda capturing constexpr by reference</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4001?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4001</a></td>
        <td>Unimplemented core issue 588: Unqualified name lookup examines dependent base class</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Similar to core issue 591 and CODEGEN-3963, this core issue resolves a lookup issue in a function template.



In the following source code, the struct 'A' will examine the scope of the base class D&lt;T&gt; to resolve the unqualified reference to B, when the core issue resolution states that D&lt;T&gt; should be skipped and the B found in the function template 'g' should be used instead.



struct B{ void f(int); };



template&lt;class T&gt; struct D: B { };



template&lt;class T&gt; void g() {

   struct B { void f(); };

   struct A : D&lt;T&gt; {

       B m;

   };

   A a;

   a.m.f(); // Presumably, we want ::g()::B::f(), not ::B::f(int)

}



int main () {

   g&lt;int&gt;();

   return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-4000?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-4000</a></td>
        <td>Core 1601: Overload resolution for enum with fixed type</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>Core issue 1601 states that the following code should call the overload of 'b' which takes a char argument, but the compiler chooses the int overload.



enum A : char { a };

int b(char) { return 1; }

int b(int) { return 999; }



int main()

{

    printf("%d\n", b(a));

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3999?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3999</a></td>
        <td>Unimplemented core issue 1374: Conversion sequence ranks qualification before reference binding</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code will print B, when both gcc and clang print A. This is due to a resolution to core issue 1374, which reorders the rankings of conversion sequences such that qualification difference are accounted for after reference binding differences, rather than before.



#include &lt;stdio.h&gt;

typedef int * T1;

typedef int *const  T2;

void foo(T1 &amp;) { printf("A\n"); } // (1)

void foo(T2 &amp;&amp;) { printf("B\n"); } // (2)

int main() {

  foo((int *)0); // Normally prefers (2), but now prefers

  return 0;         // (1) in GNU and Clang modes.

} </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3998?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3998</a></td>
        <td>Unimplemented core issue 1951: cv-qualified void and scalar types are not literal types</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>The type_trait helper std::remove_cv can ensure that qualifications have been stripped when using std::is_literal_type.</td>
        <td>The std::is_literal_type template function from the type_traits helper will erroneously have a value of 'false' for cv-qualified void and scalar types.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3993?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3993</a></td>
        <td>Constant initialiation may take place before dynamic initialization</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the following code, the rvalue reference 'br' will be initialized after the variable 'a', even though 'br' is constant initialized and 'a' is dynamically initialized. This ordering is required by C++14 Section 3.6.2 paragraph 2.



extern int a;

extern int f();



int a = f();



int&amp;&amp; br = 5;

int f() { return br; }

 

int main() {

  if (a != 5) return 1;

  return 0;

}</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3966?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3966</a></td>
        <td>slice_array assignment failures</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>None.</td>
        <td>slice_array assign fails runtime.



clang fails same as TI compiler. Both compile with no errors.



libc++ implementation copies a slice_array to another slice_array, stride by stride, and with both pointing to same original valarray. The original valarray changes values which in turn changes the values in the slice_array being assigned from.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3965?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3965</a></td>
        <td>Invalid conversion on static_cast from T1 to rvalue reference of T2</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code results in a syntax error, while it is accepted by both gcc and clang.



int main()

{

    char c = 1;

    const int &amp;&amp;r = static_cast&lt;const int&amp;&amp;&gt;(c);

    return r;

}



As a workaround, 'c' may be cast to int. However, doing so will not bind reference r to the variable c.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3964?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3964</a></td>
        <td>Unimplemented core issue 1467: Overloads and initializations with single-element initializer_list</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>This core issue has gone many iterations of fixes, and boils down to the issue of:



void foo(int x); // #1

void foo(std::initializer_list&lt;char&gt; x); // #2

foo({23}); // Calls #1 or #2?



The compiler currently calls #1, while gcc/clang both call #2.</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3963?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3963</a></td>
        <td>Unimplemented core issue 591: Name lookup in dependent base class that is also the current instantiation</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The following code currently results in an error because the reference to B in the definition of A_&lt;T&gt;::C:: D is resolved to be C::B, which is void. Core issue 591 resolves this reference to A_&lt;T&gt;::B, which is int.



template&lt;class T&gt;

struct A_ {

	typedef int B;

	struct C {

		typedef void B;

		struct D;

	};

};

template&lt;class T&gt;

struct A_&lt;T&gt;::C::D : A_&lt;T&gt; {

	B b;

};</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3962?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3962</a></td>
        <td>Core Issue 1804 unimplemented: friend declaration does not apply to class template specializations</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>The compiler does not yet implement the resolution to core issue 1804 involving template friend declarations applying to specializations of a class template. In the following code sample, a member of class C is inaccessible through a template friend declaration when the associated class template is a specialization.



class C_;



// Class template

template&lt;class T&gt; struct A_ {

  int f(const C_&amp;);

  struct D {

    int g() { return 8; }

  };

};



// Specialization

template&lt;&gt; struct A_&lt;int&gt; {

  int f(const C_&amp;);

  struct D {

    int g() { return 18; }

  };

};



class C_ {

  template&lt;class T&gt; friend int A_&lt;T&gt;::f(const C_&amp;); // friend declaration

  int member;

public:

  C_(int i) : member(i) { }

};



template&lt;class U&gt;

int A_&lt;U&gt;::f(const C_&amp; c)

  { return c.member; } // Not specialized, C::member is accessible



int A_&lt;int&gt;::f(const C_&amp; c)

  { return 10+c.member; } // Specialized, C::member is inaccessible</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3961?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3961</a></td>
        <td>Pack expansion in template parameter list fails</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3951?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3951</a></td>
        <td>Spurious error on bypassing initialization of trivially constructible objects</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3948?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3948</a></td>
        <td>Spurious syntax error on alignas in alias declaration</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td>In the following code, the 'alignas' attribute on the declaration of s1a is marked as a syntax error, even though the C++ 14 grammar explicitly allows it.



namespace a_ {

  struct alignas(0) s1 { int i; };

}

int main() {

  using s1a alignas(0) = a_::s1;

}



Furthermore, alignas will currently be ignored in relaxed mode or marked as an error in strict mode if used to specify the alignment of an enumeration type or a lambda object.

</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3947?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3947</a></td>
        <td>Spurious error on unevaluated use of undefined constexpr function</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-3946?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-3946</a></td>
        <td>Spurious error on global qualifier of struct template</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00052531?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00052531</a></td>
        <td>Incorrect value assigned to a forward reference of a symbol defined in terms of the section's PC ($) after jump expansion</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>Two workarounds are possible:
1) Use a label to get the value of the PC at a key location instead of "symbol .equ $"
2) Replace the jump that will be expanded with an already expanded form.  In the example, the jump could be replaced with:
        JLO     $+6
        BR    label1</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/CODEGEN-1295?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">CODEGEN-1295</a></td>
        <td>MSP430 RTS rint() double routines failing for some inputs</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>Avoid using the rint() RTS routines with double arguments and instead use the corresponding rint() float routines.
</td>
        <td>MSP430 RTS routines rint() rintl() lrint() lrintl() llrint() llrintl() failing for some inputs with double arguments.
</td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00051908?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00051908</a></td>
        <td>Print a more friendly message when using a lnk.cmd with too large memory</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00049280?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00049280</a></td>
        <td>Ill advised enum scalar usage gets MISRA diagnostic, but similar usage of enum array does not</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00049278?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00049278</a></td>
        <td>Array that is correctly initialized erroneously gets a MISRA diagnostic about size not being specified</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00047833?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00047833</a></td>
        <td>msp C++ cpp compiled with printf_support=minimal causes cout to output incorrect results</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>Instead either compile without --printf_support, or choose options nofloat or full.</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00046695?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00046695</a></td>
        <td>Floating point addition rounding error</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00046115?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00046115</a></td>
        <td>MSP430 RTS float arithmetic functions do not round correctly</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00046113?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00046113</a></td>
        <td>C2000 RTS float arithmetic functions do not round correctly</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00044526?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00044526</a></td>
        <td>Compiler emits bogus DW_OP_reg16 for split argument</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00040934?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00040934</a></td>
        <td>Structure is not initialized correctly when using -o2 or -o3 optimization</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>The initialization will have to be done at run-time, through a __sti initialization routine. You can see this routine when compiling without optimization. To workaround the compiler removing this initialization routine, initialize the object at the beginning of main:

Info2.mSize = ((unsigned)_end_isr_stack - (unsigned)_start_isr_stack);
</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00038293?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00038293</a></td>
        <td>Relocation overflows for BIT instruction using 20-bit pointer</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00038178?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00038178</a></td>
        <td>Should forbid non-const objects larger than 64k in large model if --near_data=globals</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00018691?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00018691</a></td>
        <td>Linker gives misleading warning when dot expressions used in SECTION directive for .stack section</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td> </td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008685?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008685</a></td>
        <td>DWARF does not correctly represent variables stored in register pairs</td>
        <td>Planned</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>
Although 'var1' and 'var2' are shown to be in single registers, a 
debugger could determine that they are actually stored in register 
pairs by looking at the type of the variables:

   [00000113] DW_TAG_base_type
    DW_AT_name    long long
    DW_AT_encoding    0x5
    DW_AT_byte_size    0x8

The base type indicates that the size of the variables is 0x8 bytes.  
Since a single register can only store 0x4 bytes of information, it 
would take two registers to hold this values.

On TI architectures, values stored in multiple registers are always 
stored in consecutive registers.  Thus, the debugger would know that 
if the entire value could not fit in A4, the rest of the value must be 
in A5.  A5 would contain the upper 32 bits of the value.



</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008652?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008652</a></td>
        <td>pow(2,x) has fairly significant rounding error</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>
Please describe the workaround for this problem.


</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008630?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008630</a></td>
        <td>printf gives wrong value for pointer when its value is incremented</td>
        <td>Open</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>
To get rid of the warning message modify the printf statement as 
follows:
  printf('0x%lx\n', 0x10000 + (t=(long int)&amp;global_var));
This modified code executes correctly too.


</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008543?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008543</a></td>
        <td>Forward reference in .space generates an internal error</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>
none


</td>
        <td> </td>
        </tr><tr>
        <td><a href="https://cqweb.ext.ti.com/cqweb/restapi/SDO-Web/SDOWP/RECORD/SDSCM00008248?format=HTML&amp;noframes=true&amp;recordType=IncidentReport&amp;loginId=readonly&amp;password=readonly">SDSCM00008248</a></td>
        <td>Compilers on PC will not work without TMP set</td>
        <td>Accepted</td>
        <td>MSP430_18.12.0.LTS</td>
        <td></td>
        <td>
Set the TMP environment variable, even if just set to . (current directory)


</td>
        <td> </td>
        </tr></tbody></table>
    <br>
    <b>Generated on Mon Oct  7 18:36:20 2019 </b>
    
    </body></html>